#!/usr/bin/env ruby
require File.expand_path(
    File.join(File.dirname(__FILE__), '..', 'lib', 'tournament'))

require 'rubygems'
require 'main'
require 'yaml'

Main do

  # Loads the pool from the save file.  If the save file
  # does not exist, creates a default pool
  def load_pool
    @pool = YAML::load_file(save_file_name)
  end

  def save_file_name
    params['save-file'].value
  end

  def init_pool
    @pool = Tournament::Pool.ncaa_2008
    @pool.bracket.scoring_strategy = Tournament::Bracket.strategy_for_name(params['scoring'].value)
  end

  def save_pool
    if @pool
      File.open(save_file_name, "w") do |f|
        YAML::dump(@pool, f)
      end
    end
  end

  mode('install_webgui') do
    description 'Installs the Rails webgui.'
    def run
    end
  end

  option('save-file', 's') do
    optional
    argument :required
    default 'pool.yml'
    arity 1
    description "Save file for the pool."
  end

  mode('setup') do
    description "Sets up the pool the first time"
    option('scoring', 'S') do
      optional
      argument :required
      arity 1
      default 'basic_scoring_strategy'
      validate {|s| Tournament::Bracket.available_strategies.include?(s)}
      description "Sets the scoring strategy, should be one of #{Tournament::Bracket.available_strategies.join(', ')}"
    end
    def run
      init_pool
      puts "Initialized new pool"
      puts "Scoring:"
      puts @pool.bracket.scoring_strategy.description
      save_pool
    end
  end

  mode('update') do
    option('entry', 'e') do
      optional
      argument :required
      default 'tournament.yml'
      arity 1
      description "Update the tournament entry using supplied yaml file"
    end
    def run
      load_pool
      tournament = YAML::load_file(params['entry'].value)
      @pool.bracket = tournament.picks
      save_pool 
    end
  end

  mode('fee') do
    argument('amount') do
      required
      cast :integer
      arity 1
      description "The fee charged per entry."
    end
    def run
      load_pool
      @pool.entry_fee = params['amount'].value
      save_pool
    end
  end

  mode('payout') do
    option('constant-amount', 'C') do
      optional
      arity 1
      cast :boolean
      description "Specify if the payout is a constant amount rather than a percentage."
    end
    argument('rank') do
      required
      arity 1
      description "The rank associated with the payout, such as 1, 2, 3 or last"
    end
    argument('amount') do
      required
      cast :integer
      arity 1
      description "The amount of the payout, either a percentage or constant amount.  If a constant amount, the --constant-amount option must be specified."
    end
    def run
      load_pool
      rank = params['rank'].value
      if 'last' == rank
        rank = :last
      else
        rank = rank.to_i
      end
      amount = params['amount'].value
      amount = -amount if params['constant-amount'].value
      @pool.set_payout(rank, amount)
      save_pool
    end
  end

  mode('entry') do
    option('add', 'a') do
      optional
      argument :required
      arity -1
      description "Add an entry yaml file to the pool"
    end
    option('remove', 'r') do
      optional
      argument :required
      arity -1
      description "Remove an entry by name"
    end
    def run
      load_pool
      if params['add'].given?
        @pool.add_entry_yaml(params['add'].value)
        save_pool 
      elsif params['remove'].given?
        @pool.remove_by_name(params['remove'].value)
        save_pool 
      else
        puts "Please specify add or remove"
        print usage.to_s
        exit_warn!
      end
    end
  end
  
  mode('dump') do
    option('entry', 'e') do
      optional
      argument :required
      default 'tournament.yml'
      description "Dump the pool entry object to a yaml file."
    end
    def run
      load_pool
      tournament = Tournament::Entry.new('Tournament', @pool.bracket, 0)
      File.open(params['entry'].value, "w") do |f|
        YAML::dump(tournament, f)
      end
    end
  end

  mode('report') do
    available_reports = Tournament::Pool.instance_methods(false).map do |name|
      if idx = name.index("_report")
        name[0,idx]
      else
        nil
      end
    end.compact
    argument('type') do
      required
      arity 1
      validate {|rt| available_reports.include?(rt)}
      description "Which report to run among #{available_reports.join(', ')}"
    end
    def run
      load_pool
      @pool.send("#{params['type'].value}_report")
    end
  end

  def run
    print usage.to_s
    exit_warn!
  end

end
